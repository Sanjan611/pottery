/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    ChangeRequestPlan: ClassViewer<'ChangeRequestPlan', "description" | "new_features" | "modified_features" | "new_tasks" | "modified_tasks" | "impact_analysis">;
    
    Dependency: ClassViewer<'Dependency', "from_description" | "to_description" | "type">;
    
    Feature: ClassViewer<'Feature', "name" | "description" | "linked_intent" | "tasks" | "ux_spec">;
    
    FeatureModification: ClassViewer<'FeatureModification', "feature_name" | "reason" | "new_tasks" | "updated_tasks">;
    
    ImpactAnalysis: ClassViewer<'ImpactAnalysis', "affected_features" | "affected_tasks" | "reasoning" | "risk_level">;
    
    ProductIntent: ClassViewer<'ProductIntent', "name" | "description" | "sub_intents">;
    
    SubIntent: ClassViewer<'SubIntent', "name" | "description" | "features">;
    
    Task: ClassViewer<'Task', "type" | "description" | "dependencies">;
    
    TaskModification: ClassViewer<'TaskModification', "task_description" | "modification_reason" | "new_description">;
    
    TaskUpdate: ClassViewer<'TaskUpdate', "original_description" | "new_description" | "reason">;
    
    UXSpec: ClassViewer<'UXSpec', "experience_goal" | "design_refs">;
    
    
    DependencyType: EnumViewer<'DependencyType', "Requires" | "Blocks" | "Impacts" | "Supersedes">;
    
    RiskLevel: EnumViewer<'RiskLevel', "Low" | "Medium" | "High">;
    
    TaskType: EnumViewer<'TaskType', "Backend" | "Frontend" | "Test" | "Infrastructure">;
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "ChangeRequestPlan","Dependency","Feature","FeatureModification","ImpactAnalysis","ProductIntent","SubIntent","Task","TaskModification","TaskUpdate","UXSpec",
          ]),
          enums: new Set([
            "DependencyType","RiskLevel","TaskType",
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.ChangeRequestPlan = this.tb.classViewer("ChangeRequestPlan", [
          "description","new_features","modified_features","new_tasks","modified_tasks","impact_analysis",
        ]);
        
        this.Dependency = this.tb.classViewer("Dependency", [
          "from_description","to_description","type",
        ]);
        
        this.Feature = this.tb.classViewer("Feature", [
          "name","description","linked_intent","tasks","ux_spec",
        ]);
        
        this.FeatureModification = this.tb.classViewer("FeatureModification", [
          "feature_name","reason","new_tasks","updated_tasks",
        ]);
        
        this.ImpactAnalysis = this.tb.classViewer("ImpactAnalysis", [
          "affected_features","affected_tasks","reasoning","risk_level",
        ]);
        
        this.ProductIntent = this.tb.classViewer("ProductIntent", [
          "name","description","sub_intents",
        ]);
        
        this.SubIntent = this.tb.classViewer("SubIntent", [
          "name","description","features",
        ]);
        
        this.Task = this.tb.classViewer("Task", [
          "type","description","dependencies",
        ]);
        
        this.TaskModification = this.tb.classViewer("TaskModification", [
          "task_description","modification_reason","new_description",
        ]);
        
        this.TaskUpdate = this.tb.classViewer("TaskUpdate", [
          "original_description","new_description","reason",
        ]);
        
        this.UXSpec = this.tb.classViewer("UXSpec", [
          "experience_goal","design_refs",
        ]);
        
        
        this.DependencyType = this.tb.enumViewer("DependencyType", [
          "Requires","Blocks","Impacts","Supersedes",
        ]);
        
        this.RiskLevel = this.tb.enumViewer("RiskLevel", [
          "Low","Medium","High",
        ]);
        
        this.TaskType = this.tb.enumViewer("TaskType", [
          "Backend","Frontend","Test","Infrastructure",
        ]);
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}