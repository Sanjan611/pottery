/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

const fileMap = {
  
  "clients.baml": "// BAML Configuration for Pottery AI Planning\n\n// LLM Client Configuration\nclient<llm> GPT4 {\n  provider openai\n  options {\n    model gpt-4o\n    temperature 0.2\n    max_tokens 4000\n  }\n}\n\nclient<llm> Claude {\n  provider anthropic\n  options {\n    model claude-3-5-sonnet-20241022\n    temperature 0.2\n    max_tokens 4000\n  }\n}\n",
  "generators.baml": "// Generator configuration\ngenerator target {\n  output_type typescript\n  output_dir \"../src/baml_client\"\n  version \"0.203.0\"\n}",
  "prompts/analyze_change.baml": "// Prompt for analyzing proposed changes\n\nfunction AnalyzeChange(\n  current_graph: string,  // JSON representation of current graph\n  change_description: string\n) -> ChangeRequestPlan {\n  client GPT4\n\n  prompt #\"\n    You are analyzing a proposed change to an existing product.\n\n    Current product structure:\n    {{ current_graph }}\n\n    Requested change:\n    {{ change_description }}\n\n    Your task is to:\n    1. Determine what new Features and Tasks need to be created\n    2. Identify existing Features and Tasks that need modification\n    3. Analyze the impact across the product graph\n    4. Determine new dependencies that need to be created\n\n    IMPORTANT: All Features must be associated with SubIntents via the linked_intent field.\n\n    Guidelines:\n    - Be thorough in impact analysis\n    - Consider cascading effects (changing one feature may impact others)\n    - Identify all dependencies clearly\n    - Assess risk level (Low/Medium/High)\n    - Explain your reasoning\n    - Keep changes focused and minimal\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest TestAnalyzeSimpleChange {\n  functions [AnalyzeChange]\n  args {\n    current_graph #\"\n      {\n        \"name\": \"Todo App\",\n        \"description\": \"Simple todo list application\",\n        \"features\": [\n          {\n            \"name\": \"Task Management\",\n            \"description\": \"Create, read, update, delete tasks\",\n            \"tasks\": [\n              {\n                \"type\": \"Backend\",\n                \"description\": \"Create API endpoint for tasks CRUD\"\n              },\n              {\n                \"type\": \"Frontend\",\n                \"description\": \"Build task list UI component\"\n              },\n              {\n                \"type\": \"Test\",\n                \"description\": \"Write integration tests for task operations\"\n              }\n            ]\n          }\n        ]\n      }\n    \"#\n    change_description \"Add ability to mark tasks as completed\"\n  }\n  @@check(\n    has_description,\n    {{ this.description|length > 0 }}\n  )\n  @@check(\n    has_impact_analysis,\n    {{ this.impact_analysis.reasoning|length > 0 }}\n  )\n  @@check(\n    has_risk_level,\n    {{ this.impact_analysis.risk_level in ['Low', 'Medium', 'High'] }}\n  )\n  @@assert(\n    {{ _.checks.has_description and _.checks.has_impact_analysis }}\n  )\n}\n\ntest TestAnalyzeComplexChange {\n  functions [AnalyzeChange]\n  args {\n    current_graph #\"\n      {\n        \"name\": \"E-commerce Platform\",\n        \"description\": \"Online shopping platform\",\n        \"features\": [\n          {\n            \"name\": \"Product Catalog\",\n            \"description\": \"Browse and search products\",\n            \"tasks\": [\n              {\n                \"type\": \"Backend\",\n                \"description\": \"Product database schema\"\n              },\n              {\n                \"type\": \"Backend\",\n                \"description\": \"Search API endpoint\"\n              }\n            ]\n          },\n          {\n            \"name\": \"Shopping Cart\",\n            \"description\": \"Add items to cart and checkout\",\n            \"tasks\": [\n              {\n                \"type\": \"Backend\",\n                \"description\": \"Cart management API\"\n              },\n              {\n                \"type\": \"Frontend\",\n                \"description\": \"Cart UI component\"\n              }\n            ]\n          }\n        ]\n      }\n    \"#\n    change_description #\"\n      Add real-time inventory tracking that updates product availability\n      across the catalog and prevents adding out-of-stock items to cart\n    \"#\n  }\n  @@check(\n    identifies_multiple_features,\n    {{ this.impact_analysis.affected_features|length > 1 }}\n  )\n  @@check(\n    has_new_or_modified,\n    {{ (this.new_features|length + this.modified_features|length) > 0 }}\n  )\n  @@check(\n    has_impact_reasoning,\n    {{ this.impact_analysis.reasoning|length > 50 }}\n  )\n  @@check(\n    reasonable_latency,\n    {{ _.latency_ms < 20000 }}\n  )\n  @@assert(\n    {{ _.checks.has_new_or_modified and _.checks.has_impact_reasoning }}\n  )\n}\n\ntest TestAnalyzeBreakingChange {\n  functions [AnalyzeChange]\n  args {\n    current_graph #\"\n      {\n        \"name\": \"Social Media App\",\n        \"description\": \"Social networking platform\",\n        \"features\": [\n          {\n            \"name\": \"User Profiles\",\n            \"description\": \"User profile management\",\n            \"tasks\": [\n              {\n                \"type\": \"Backend\",\n                \"description\": \"User API with username-based lookup\"\n              }\n            ]\n          },\n          {\n            \"name\": \"Messaging\",\n            \"description\": \"Direct messaging between users\",\n            \"tasks\": [\n              {\n                \"type\": \"Backend\",\n                \"description\": \"Message API using username for recipients\"\n              }\n            ]\n          }\n        ]\n      }\n    \"#\n    change_description \"Switch from username-based to UUID-based user identification\"\n  }\n  @@check(\n    high_impact_detected,\n    {{ this.impact_analysis.risk_level in ['Medium', 'High'] }}\n  )\n  @@check(\n    affects_multiple_areas,\n    {{ this.impact_analysis.affected_features|length >= 2 }}\n  )\n  @@check(\n    has_modifications,\n    {{ this.modified_features|length > 0 or this.modified_tasks|length > 0 }}\n  )\n  @@assert(\n    {{ _.checks.high_impact_detected and _.checks.affects_multiple_areas }}\n  )\n}\n",
  "prompts/create_layered_project.baml": "// Prompts for creating layered project structure (Phase 1)\n\nfunction CreateLayeredProject(user_intent: string) -> LayeredProject {\n  client GPT4\n\n  prompt #\"\n    You are a product architect helping to design a software product using a three-layer architecture:\n\n    1. NARRATIVE LAYER - Human-first, motivation-driven\n       - Answers: \"What are we trying to do and why?\"\n       - Contains: Epics (high-level themes) and User Stories\n\n    2. STRUCTURE LAYER - Machine-reasonable, execution-oriented\n       - Answers: \"What needs to happen?\"\n       - Contains: Capabilities (what the system can do)\n\n    3. SPECIFICATION LAYER - Precise, testable, implementable\n       - Answers: \"What does done look like?\"\n       - Contains: Technical Requirements and Tasks\n\n    The user has provided this product intent:\n    {{ user_intent }}\n\n    Your task is to generate a complete three-layer project structure:\n\n    NARRATIVE LAYER:\n    - Create 2-4 Epics (major themes or goals)\n    - For each Epic, create 3-7 User Stories in the format:\n      \"As a [user type], I want [goal], so that [benefit]\"\n    - Include 2-5 acceptance criteria per User Story\n    - Link User Stories to Capabilities they require (use capability names)\n\n    STRUCTURE LAYER:\n    - Create TWO GRAPHS:\n      1. FEATURE GRAPH: Capabilities (what the system can do)\n         - Each Capability should have a clear name and description\n         - Link Capabilities back to the User Stories they satisfy\n      2. FLOW GRAPH: FlowScreens and FlowActions (user journey)\n         - Create screens for major UI states\n         - Create actions for user interactions\n         - Model screen transitions\n         - Link actions to capabilities they require\n    - Create EXPLICIT MAPPINGS between FlowActions and Capabilities\n      - For each FlowAction, create a FlowToCapabilityMapping entry\n      - Include rationale explaining why the action needs each capability\n    - Think about both features and user flows\n\n    SPECIFICATION LAYER:\n    - Create Technical Requirements (Performance, Security, Scalability, Reliability, Other)\n    - Link each Technical Requirement to the Capabilities it supports\n    - Create Tasks (atomic units of work: Backend, Frontend, Test, Infrastructure)\n    - Tasks should be specific and actionable\n\n    Guidelines:\n    - Keep the scope focused on MVP\n    - Be practical and implementable\n    - Ensure all cross-layer references are consistent\n    - User Stories should drive Capabilities\n    - Capabilities should drive Technical Requirements\n    - Technical Requirements should inform Tasks\n\n    {{ ctx.output_format }}\n  \"#\n}\n\nfunction CreateNarrativeLayer(user_intent: string) -> NarrativeLayer {\n  client GPT4\n\n  prompt #\"\n    You are creating the NARRATIVE LAYER for a software product.\n    This layer answers: \"What are we trying to do and why?\"\n\n    User intent:\n    {{ user_intent }}\n\n    Create:\n    1. 2-4 Epics (high-level themes or major goals)\n    2. For each Epic, 3-7 User Stories in format:\n       \"As a [user type], I want [goal], so that [benefit]\"\n    3. For each User Story, 2-5 acceptance criteria\n    4. Link User Stories to potential Capabilities (system features they need)\n\n    Focus on user value and motivation, not implementation.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\nfunction CreateStructureLayer(narrative: NarrativeLayer) -> StructureLayer {\n  client GPT4\n\n  prompt #\"\n    You are creating the STRUCTURE LAYER based on the narrative layer.\n    This layer answers: \"What needs to happen?\"\n\n    Given these User Stories:\n    {% for story in narrative.userStories %}\n    - {{ story.narrative }}\n      Needs capabilities: {{ story.linkedCapabilityNames }}\n    {% endfor %}\n\n    Create TWO SEPARATE GRAPHS:\n\n    1. FEATURE GRAPH (Capabilities):\n       - Create Capabilities that satisfy the User Stories above\n       - Each Capability represents what the system CAN DO\n       - Link Capabilities back to the User Stories they satisfy\n       - Think about system features, not implementation details\n       - Example capabilities: \"User Authentication\", \"Task Creation\", \"Real-time Notifications\"\n\n    2. FLOW GRAPH (Screens and Actions):\n       - Model the user journey through the application\n       - Create FlowScreens for major UI states (e.g., \"Login Screen\", \"Dashboard\", \"Task Detail\")\n       - Create FlowActions for user interactions on each screen\n       - Each FlowAction should:\n         * Have a triggerType: \"user\" (user-initiated) or \"system\" (automatic)\n         * Reference a parentScreen (which screen it belongs to)\n         * Optionally have a nextScreen (screen transition after action)\n         * Link to Capabilities it requires (via linkedCapabilityNames)\n       - FlowScreens should list their actions in actionNames array\n       - Model screen transitions: when a user action leads to another screen, set nextScreen\n       - Think about the user flow: login → dashboard → task detail → edit task → save → return to dashboard\n\n    Guidelines for Flow Modeling:\n    - Create screens for distinct UI states (don't over-fragment)\n    - Create actions for meaningful user interactions (click, submit, navigate)\n    - System actions (auto-save, notifications) should have triggerType: \"system\"\n    - User actions (click button, submit form) should have triggerType: \"user\"\n    - Link actions to capabilities they need (e.g., \"Login\" action needs \"User Authentication\" capability)\n    - Model transitions: actions that navigate to another screen should have nextScreen set\n\n    Example Flow:\n    - Screen: \"Login Screen\"\n      - Action: \"Submit Login\" (user) → nextScreen: \"Dashboard\"\n      - Action: \"Forgot Password\" (user) → nextScreen: \"Password Reset Screen\"\n    - Screen: \"Dashboard\"\n      - Action: \"View Task\" (user) → nextScreen: \"Task Detail\"\n      - Action: \"Auto-refresh Tasks\" (system) → no nextScreen\n\n    Think about both what the system CAN DO (capabilities) and HOW users interact with it (flows).\n\n    3. EXPLICIT MAPPINGS (Many-to-Many Relationships):\n       - For EACH FlowAction, create explicit FlowToCapabilityMapping entries\n       - Each mapping connects a FlowAction to one or more Capabilities it requires\n       - IMPORTANT: Create mappings even if the FlowAction already has linkedCapabilityNames\n       - For each mapping, provide a clear rationale explaining:\n         * Why this specific action requires this capability\n         * How the capability enables the action\n         * What would break if this mapping didn't exist\n       - Example mapping:\n         * FlowAction: \"Submit Login\"\n         * Capabilities: [\"User Authentication\"]\n         * Rationale: \"The Submit Login action requires the User Authentication capability to verify credentials and create a user session. Without this capability, the login action cannot complete successfully.\"\n\n    MAPPING GUIDELINES:\n    - Every FlowAction should have at least one mapping (even if just one capability)\n    - If a FlowAction requires multiple capabilities, create a single mapping with all of them (don't create separate mappings for each)\n    - The rationale should be specific and explain the dependency clearly\n    - Focus on what capabilities are ESSENTIAL for the action to work, not just nice-to-have\n\n    {{ ctx.output_format }}\n  \"#\n}\n\nfunction CreateSpecificationLayer(structure: StructureLayer) -> SpecificationLayer {\n  client GPT4\n\n  prompt #\"\n    You are creating the SPECIFICATION LAYER based on the structure layer.\n    This layer answers: \"What does done look like?\"\n\n    Given these Capabilities:\n    {% for cap in structure.capabilities %}\n    - {{ cap.name }}: {{ cap.description }}\n    {% endfor %}\n\n    Create:\n    1. Technical Requirements (Performance, Security, Scalability, Reliability, Other)\n       - Link each to the Capabilities it supports\n       - Be specific and measurable\n\n    2. Tasks (Backend, Frontend, Test, Infrastructure)\n       - Atomic units of work\n       - Actionable and specific\n       - Realistic dependencies between tasks\n\n    Focus on implementation details and technical precision.\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest TestCreateLayeredProject {\n  functions [CreateLayeredProject]\n  args {\n    user_intent #\"\n      Build a collaborative task management app where teams can create projects,\n      assign tasks, track progress, and communicate in real-time.\n    \"#\n  }\n}\n\ntest TestCreateNarrativeLayer {\n  functions [CreateNarrativeLayer]\n  args {\n    user_intent #\"\n      Build a collaborative task management app.\n    \"#\n  }\n}\n",
  "prompts/create_project.baml": "// Prompt for creating initial project structure\n\nfunction CreateProjectStructure(user_intent: string) -> ProductIntent {\n  client GPT4\n\n  prompt #\"\n    You are a product architect helping to design a software product.\n\n    The user has provided this product intent:\n    {{ user_intent }}\n\n    Your task is to:\n    1. Create a clear ProductIntent with a concise name and description\n    2. Break it down into 2-5 strategic SubIntents (pillars like \"User Experience\", \"Scalability\", \"Security\")\n    3. For EACH SubIntent, generate 2-6 Features (distinct user-facing capabilities)\n    4. For each Feature, generate 3-10 Tasks (atomic units of work)\n    5. Add UXSpecs where relevant for user-facing features\n\n    IMPORTANT: Features should ONLY be defined within SubIntents, not at the ProductIntent level.\n\n    Guidelines:\n    - Tasks should be actionable and specific\n    - Task types: Backend, Frontend, Test, Infrastructure\n    - Dependencies should be realistic (a task can depend on other tasks)\n    - Keep descriptions clear and concise\n    - Focus on the MVP scope\n    - Be practical and implementable\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest TestCreateProjectStructure {\n  functions [CreateProjectStructure]\n  args {\n    user_intent #\"\n      Create an app that allows users to manage their subscriptions.\n    \"#\n  }\n}\n",
  "prompts/decompose_tasks.baml": "// Prompt for decomposing features into tasks\n\nfunction DecomposeFeatureToTasks(\n  feature_name: string,\n  feature_description: string,\n  context: string  // Related features and constraints\n) -> Task[] {\n  client GPT4\n\n  prompt #\"\n    You are breaking down a feature into atomic tasks.\n\n    Feature: {{ feature_name }}\n    Description: {{ feature_description }}\n\n    Context:\n    {{ context }}\n\n    Generate 3-10 specific, actionable tasks that implement this feature.\n\n    Guidelines:\n    - Tasks should be atomic (single responsibility)\n    - Include backend, frontend, and test tasks\n    - Specify dependencies between tasks\n    - Tasks should be implementable by a developer\n    - Consider infrastructure needs (database, API, etc.)\n    - Be specific and concrete\n\n    {{ ctx.output_format }}\n  \"#\n}\n\ntest TestDecomposeSimpleFeature {\n  functions [DecomposeFeatureToTasks]\n  args {\n    feature_name \"User Authentication\"\n    feature_description \"Allow users to sign up and log in with email and password\"\n    context \"This is for a web application using REST API\"\n  }\n  @@check(\n    has_minimum_tasks,\n    {{ this|length >= 3 }}\n  )\n  @@check(\n    has_maximum_tasks,\n    {{ this|length <= 10 }}\n  )\n  @@check(\n    has_tasks,\n    {{ this|length > 0 }}\n  )\n  @@check(\n    reasonable_latency,\n    {{ _.latency_ms < 15000 }}\n  )\n  @@assert(\n    {{ _.checks.has_minimum_tasks and _.checks.has_maximum_tasks }}\n  )\n}\n\ntest TestDecomposeComplexFeature {\n  functions [DecomposeFeatureToTasks]\n  args {\n    feature_name \"Payment Processing\"\n    feature_description \"Integrate Stripe for subscription payments with webhook handling\"\n    context #\"\n      The application already has user authentication.\n      Need to handle monthly and annual subscriptions.\n      Must comply with PCI DSS requirements.\n    \"#\n  }\n  @@check(\n    has_minimum_tasks,\n    {{ this|length >= 3 }}\n  )\n  @@check(\n    has_multiple_tasks,\n    {{ this|length >= 5 }}\n  )\n  @@check(\n    reasonable_latency,\n    {{ _.latency_ms < 20000 }}\n  )\n  @@assert(\n    {{ _.checks.has_minimum_tasks and _.checks.reasonable_latency }}\n  )\n}\n",
  "types/entities.baml": "// Core entity type definitions\n\nclass ProductIntent {\n  name string\n  description string\n  sub_intents SubIntent[]\n}\n\nclass SubIntent {\n  name string\n  description string\n  features Feature[]\n}\n\nclass Feature {\n  name string\n  description string\n  linked_intent string  // SubIntent name\n  tasks Task[]\n  ux_spec UXSpec?\n}\n\nclass Task {\n  type TaskType\n  description string\n  dependencies string[]  // Task descriptions they depend on\n}\n\nenum TaskType {\n  Backend\n  Frontend\n  Test\n  Infrastructure\n}\n\nclass UXSpec {\n  experience_goal string\n  design_refs string[]\n}\n\nclass Dependency {\n  from_description string\n  to_description string\n  type DependencyType\n}\n\nenum DependencyType {\n  Requires\n  Blocks\n  Impacts\n  Supersedes\n}\n\nclass ChangeRequestPlan {\n  description string\n  new_features Feature[]\n  modified_features FeatureModification[]\n  new_tasks Task[]\n  modified_tasks TaskModification[]\n  impact_analysis ImpactAnalysis\n}\n\nclass FeatureModification {\n  feature_name string\n  reason string\n  new_tasks Task[]\n  updated_tasks TaskUpdate[]\n}\n\nclass TaskUpdate {\n  original_description string\n  new_description string\n  reason string\n}\n\nclass TaskModification {\n  task_description string\n  modification_reason string\n  new_description string?\n}\n\nclass ImpactAnalysis {\n  affected_features string[]\n  affected_tasks string[]\n  reasoning string\n  risk_level RiskLevel\n}\n\nenum RiskLevel {\n  Low\n  Medium\n  High\n}\n\n// ========================================\n// Layered Architecture Types (Phase 1)\n// ========================================\n\n// Narrative Layer\nclass Epic {\n  name string\n  description string\n  userStoryNames string[]  // Will be resolved to UserStory IDs\n}\n\nclass UserStory {\n  narrative string  // \"As a [user], I want [goal], so that [benefit]\"\n  acceptanceCriteria string[]\n  epicName string  // Will be resolved to Epic ID\n  linkedCapabilityNames string[]  // Will be resolved to Capability IDs in structure layer\n}\n\n// Structure Layer - Feature Graph\nclass Capability {\n  name string\n  description string  // What the system does\n  linkedUserStoryNames string[]  // Back-reference to narrative layer\n}\n\n// Structure Layer - Flow Graph\nclass FlowScreen {\n  name string\n  description string\n  actionNames string[]  // Will be resolved to FlowAction IDs\n}\n\nclass FlowAction {\n  name string\n  description string\n  triggerType FlowActionTriggerType\n  parentScreenName string  // Will be resolved to FlowScreen ID\n  nextScreenName string?  // Optional transition to another screen\n  linkedCapabilityNames string[]  // For many-to-many mapping to capabilities\n}\n\nenum FlowActionTriggerType {\n  User\n  System\n}\n\n// Many-to-many mapping between FlowActions and Capabilities\nclass FlowToCapabilityMapping {\n  flowActionName string  // Will be resolved to FlowAction ID\n  capabilityNames string[]  // Will be resolved to Capability IDs\n  rationale string  // Why this mapping exists - explain the relationship\n}\n\n// Specification Layer\nclass TechnicalRequirement {\n  type TechnicalRequirementType\n  specification string\n  linkedCapabilityNames string[]  // Which capabilities this supports\n}\n\nenum TechnicalRequirementType {\n  Performance\n  Security\n  Scalability\n  Reliability\n  Other\n}\n\n// Layered project structure\nclass NarrativeLayer {\n  epics Epic[]\n  userStories UserStory[]\n}\n\nclass StructureLayer {\n  capabilities Capability[]  // Feature graph\n  flowScreens FlowScreen[]  // Flow graph\n  flowActions FlowAction[]  // Flow graph\n  mappings FlowToCapabilityMapping[]  // Explicit many-to-many mappings between actions and capabilities\n}\n\nclass SpecificationLayer {\n  technicalRequirements TechnicalRequirement[]\n  tasks Task[]\n}\n\nclass LayeredProject {\n  narrativeLayer NarrativeLayer\n  structureLayer StructureLayer\n  specificationLayer SpecificationLayer\n}\n",
}
export const getBamlFiles = () => {
    return fileMap;
}